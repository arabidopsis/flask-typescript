from __future__ import annotations

from collections.abc import Sequence
from typing import Any
from typing import get_args
from typing import get_type_hints
from typing import IO

from jinja2 import Template
from sqlalchemy import ColumnDefault
from sqlalchemy import inspect
from sqlalchemy.orm import DeclarativeBase

from ..utils import lenient_issubclass

PY_TEMPLATE = Template(
    """
class {{name}}(pydantic.BaseModel):
{%- for k,v in columns.items() %}
    {{k}}: {{v[0]}}{%if v[1] %} = {{v[1]}}{% endif %}
{%- endfor %}
""",
)


def tos(a: Any) -> str:
    if a.__module__ in {"builtins"}:
        if a.__name__ in {"list", "set"}:
            return f"{a.__name__}[{tos(get_args(a)[0])}]"
        return f"{a.__name__}"
    if a.__module__ in {"types", "typing"}:
        return str(a)
    if lenient_issubclass(a, DeclarativeBase):
        return f"{a.__name__}"
    if a.__module__ == "__main__":
        return f"{a.__name__}"
    return f"{a.__module__}.{a.__name__}"


def gettypes(dc: type[DeclarativeBase]) -> set[str]:
    def g(args: Any) -> Any:
        istype = isinstance(args, type)
        if istype and args.__module__ not in {"builtins"}:
            yield args.__module__
            return

        if hasattr(args, "__module__") and args.__module__ in {"typing"}:
            yield args.__module__

        for a in get_args(args):
            yield from g(a)

    s: set[Any] = set()
    for typ in get_type_hints(dc).values():
        s.update(g(typ))
    return s


def get_defaults(dc: type[DeclarativeBase]) -> dict[str, Any]:
    ret = {}
    for k, v in get_type_hints(dc).items():
        prop = getattr(dc, k).property
        if not hasattr(prop, "columns"):
            continue
        v = prop.columns[0].default
        if isinstance(v, ColumnDefault):
            ret[k] = v.arg
    return ret


class PYDHandle:
    def __init__(self) -> None:
        self.imports: set[str] = set()
        self.txt: list[str] = []

    def relationships(self, dc: type[DeclarativeBase]) -> dict[str, tuple[str, str]]:
        ret = {}
        for r in inspect(dc).relationships:  # type: ignore
            n = r.mapper.class_.__name__
            s = f"list[{n}]" if r.uselist else f"{n} | None"
            d = "[]" if r.uselist else "None"
            ret[r.key] = (s, d)
        return ret

    def add(self, dcs: Sequence[type[DeclarativeBase]]) -> None:
        dcs = list(dcs)
        imports = {
            s for dc in dcs for s in gettypes(dc) if s not in {"builtins", "__main__"}
        }
        self.imports.update(imports)

        def torepr(v: Any) -> str | None:
            if v is None:
                return v
            return repr(v)

        for dc in dcs:
            defaults = get_defaults(dc)
            columns = {
                k: (tos(get_args(v)[0]), torepr(defaults.get(k, None)))
                for k, v in get_type_hints(dc).items()
            }

            columns.update(self.relationships(dc))

            self.txt.append(PY_TEMPLATE.render(name=dc.__name__, columns=columns))

    def key(self, imp: str) -> str:
        if imp in {"typing", "types"}:
            return "aaa" + imp
        if "." in imp:
            return "zzz" + imp
        return imp

    def show(self, out: IO[str]) -> None:
        print("# generated by flask-typescript", file=out)
        print("from __future__ import annotations", file=out)
        self.imports.add("pydantic")
        for v in sorted(self.imports, key=self.key):
            print(f"import {v}", file=out)

        for t in self.txt:
            print(t, file=out)


def sqla_to_py(dcs: Sequence[type[DeclarativeBase]], out: IO[str]) -> None:
    h = PYDHandle()
    h.add(dcs)
    h.show(out)
