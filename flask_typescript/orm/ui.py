from __future__ import annotations

import click
from flask import current_app
from flask import has_app_context
from sqlalchemy import Table

from ..cli import ts_cli
from ..utils import maybeclose
from .orm import datacolumn
from .orm import dodatabase
from .orm import find_all_models
from .orm import model_ts


def geturl(url: str | None) -> list[str]:
    if not url:
        if not has_app_context():
            raise click.BadParameter("specify --url to database", param_hint="url")
        url = current_app.config.get("SQLALCHEMY_DATABASE_URI")
        if url is None:
            binds = current_app.config.get("SQLALCHEMY_BINDS")
            if binds is None:
                raise click.BadParameter(
                    "no SQLALCHEMY_DATABASE_URI configured, try '--url' option",
                )
            urls = [str(u) for u in binds.values()]
        else:
            urls = [str(url)]
    else:
        urls = [url]
    return urls


@ts_cli.group(
    help=click.style("""Typescripting sqlalchemy tables/models""", fg="magenta"),
)
def sqla() -> None:
    pass


@sqla.command("tables-meta")
@click.option(
    "-o",
    "--out",
    type=click.Path(dir_okay=False),
    help="output file",
)
@click.option(
    "--url",
    help="sqlalchemy connection url to use",
)
@click.option(
    "--no-preamble",
    is_flag=True,
    help="don't output preamble",
)
@click.argument("tables", nargs=-1)
def tables_cmd(
    url: str | None,
    tables: tuple[str],
    out: str | None,
    no_preamble: bool = False,
) -> None:
    """Typescript metadata from tables in sqlalchemy.

    Create a typescript datastructure that has metadata
    such as maximum string length, data type of the SQL columns.
    """
    urls = geturl(url)
    with maybeclose(out, "wt") as fp:
        for url_ in urls:
            dodatabase(url_, *tables, preamble=not no_preamble, out=fp)


@sqla.command("models")
@click.option(
    "-o",
    "--out",
    type=click.Path(dir_okay=False),
    help="output file",
)
@click.argument("modules", nargs=-1)
def models_cmd(modules: tuple[str], out: str | None) -> None:
    """Typescript types from sqlalchemy Declarative Models.

    Specify that python MODULES that contain sqlalchemy Declarative classes.
    If you have a function that generates these classes then use `:function_name`
    at the end of the module.
    """

    if not modules:
        return

    with maybeclose(out, "wt") as fp:
        print("// generated by flask-typescript", file=fp)

        for models in find_all_models(*modules):
            model_ts(*models, out=fp)


@sqla.command("models-meta")
@click.option(
    "-o",
    "--out",
    type=click.Path(dir_okay=False),
    help="output file",
)
@click.option(
    "--no-preamble",
    is_flag=True,
    help="don't output preamble",
)
@click.argument("modules", nargs=-1)
def models_tables_cmd(
    modules: tuple[str],
    out: str | None,
    no_preamble: bool = False,
) -> None:
    """Typescript metadata from sqlalchemy Declarative Models.

    Create a typescript datastructure that has metadata
    such as maximum string length, data type of the SQL columns.

    Specify that python MODULES that contain sqlalchemy Declarative classes.
    If you have a function that generates these classes then use `:function_name`
    at the end of the module.
    """
    from .orm import table_ts

    if not modules:
        return

    with maybeclose(out, "wt") as fp:
        print("// generated by flask-typescript", file=fp)
        if not no_preamble:
            datacolumn(fp)

        for models in find_all_models(*modules):
            table_ts(out, [m.__table__ for m in models], metadata_only=True)  # type: ignore


def get_tables(
    url: str | None,
    schema: str | None = None,
    tables: list[str] | None = None,
) -> tuple[list[Table], list[str]]:
    from sqlalchemy import create_engine, MetaData

    urls = geturl(url)
    ttables: list[Table] = []
    uout = []

    for url in urls:
        engine = create_engine(url)
        uout.append(str(engine.url))  # hide password
        meta = MetaData()
        if tables:
            meta.reflect(bind=engine, only=tables, schema=schema)
            if schema is not None:
                tables = [f"{schema}.{t}" for t in tables]
        else:
            meta.reflect(bind=engine, schema=schema)
            tables = list(meta.tables.keys())

        ttables.extend([meta.tables[t] for t in sorted(tables)])
    return ttables, uout


@sqla.command()
@click.option(
    "-o",
    "--out",
    type=click.Path(dir_okay=False),
    help="output file",
)
@click.option(
    "--url",
    help="sqlalchemy connection url to use",
)
@click.option("--base", default="Base", help="base class of models")
@click.option("--schema", help="schema to use")
@click.option(
    "--throw",
    is_flag=True,
    help="throw on unknown column type (instead of just guessing)",
)
@click.option("--abstract", is_flag=True, help="make classes abstract")
@click.argument("tables", nargs=-1)
def tosqla(
    url: str | None,
    base: str,
    out: str | None,
    abstract: bool,
    schema: str | None,
    tables: tuple[str, ...],
    throw: bool,
) -> None:
    """Render SQL tables into sqlalchemy.orm.Declarative classes."""

    from .mksqla import ModelMaker

    ttables, uout = get_tables(url, schema, list(tables))
    mm = ModelMaker(
        with_tablename=not abstract,
        abstract=abstract,
        base=base,
        throw=throw,
        aspydantic=False,
    )
    with maybeclose(out, "wt") as fp:
        print(f'# from {", ".join(uout)}', file=fp)
        mm(ttables, out=fp)


@sqla.command()
@click.option(
    "-o",
    "--out",
    type=click.Path(dir_okay=False),
    help="output file",
)
@click.option(
    "--url",
    help="sqlalchemy connection url to use",
)
@click.option("--schema", help="schema to use")
@click.option(
    "--throw",
    is_flag=True,
    help="throw on unknown column type (instead of just guessing)",
)
@click.argument("tables", nargs=-1)
def topydantic(
    url: str | None,
    out: str | None,
    schema: str | None,
    tables: tuple[str, ...],
    throw: bool,
) -> None:
    """Render SQL tables into pydantic classes."""

    from .mksqla import ModelMaker

    ttables, uout = get_tables(url, schema, list(tables))
    mm = ModelMaker(
        with_tablename=True,
        abstract=False,
        base="BaseModel",
        throw=throw,
        aspydantic=True,
    )
    with maybeclose(out, "wt") as fp:
        print(f'# from {", ".join(uout)}', file=fp)
        mm(ttables, out=fp)


@sqla.command("experimental")
@click.option(
    "-o",
    "--out",
    type=click.Path(dir_okay=False),
    help="output file",
)
@click.argument("modules", nargs=-1)
def topydantic_cmd(
    modules: tuple[str],
    out: str | None,
) -> None:
    """Generate pydantic classes from sqlalchemy DeclarativeBase classes.

    Specify that python MODULES that contain sqlalchemy Declarative classes.
    If you have a function that generates these classes then use `:function_name`
    at the end of the module.
    """

    from .pyd import sqla_to_py

    if not modules:
        return

    with maybeclose(out, "wt") as fp:
        print("# generated by flask-typescript", file=fp)

        for models in find_all_models(*modules):
            sqla_to_py(models, out=fp)
